## 1. Problem with REST-ful Routing

REST, short for **Re**presentational **S**tate **T**ransfer (可重新表达的状态迁移), is a style of software architecture. It relies on a **stateless, client-server** protocol, almost always HTTP. Four most frequently used HTTP methods: GET, POST, PUT, DELETE. Endpoints are the URI/URL a HTTP request is sent to. **REST-ful** is typically used to refer to web services implementing such an architecture.

REST-ful Routing: Given a collection of records on a server, there should be a uniform URL and HTTP request method used to utilize that collection of records. And REST-ful routing with highly reational data starts to get quite challenging. 

<img width="581" alt="restful-issues" src="https://user-images.githubusercontent.com/20265633/38963276-147e0646-433f-11e8-9b45-7d069c451689.PNG">

- Deciding on a url schema gets tough when we start to have heavily nested relationships.
- When fetching heavily nested data, we can easily run into situations where we make too many HTTP requests to get the data we need.
- We're vulnerable to over fetching data where we fetch an entire company when maybe we really need the name property of the company.

The issues can be solved but takes engineering time. And this is where GraphQL comes in. GraphQL wants to fix some real big inconsistencies or challenges around REST-ful routing and also tackle big issue around over serving data in a very timely fashion.

## 2. What is GraphQL

GraphQL considers all the data in our application to look like a graph.

## 3. GraphQL with Express

<img width="579" alt="graphql-with-express" src="https://user-images.githubusercontent.com/20265633/38965852-1b148224-434d-11e8-98ec-da6036eb4108.PNG">

## 4. GraphQL Schema and Root Query

Schema file tells GraphQL exactly what our data looks like, e.g. what properties each object has and exactly how each object is related to each other. The best way to think about schema is as a bunch of functions that **return references to other objects (piece of data)** in the graph, so we can think of each of the edges in the graph as being a reslove function.

Root query is an entry point into our data.

<img width="472" alt="graphql-root-query" src="https://user-images.githubusercontent.com/20265633/39137470-a3ced082-46eb-11e8-8ce7-a51f3c2ad1e7.PNG">

<img width="472" alt="graphql-resolve-function" src="https://user-images.githubusercontent.com/20265633/39137892-bb460cf2-46ec-11e8-992c-b6eb2c93ba5b.PNG">

## 5. Query Fragments

Example:

```javascript
fragment companyDetails on Company {
	id
	name
	description
}

// Query:
{
	apple: company(id: "1") {
		...companyDetails
	}
	google: company(id: "2") {
		...companyDetails
	}
}
```

## 6. Mutations

Example:

```javascript
const mutation = new GraphQLObjectType({
	name: 'Mutation',
	fields: {
		addUser: {
			// type: refer to the data that returned from the resolve function.
			// Sometime when we have a mutation, the collection of data we're
			// operationg on and the returned type might not always be the same.
			type: UserType,
			// args: some arguments or data that going to be passed into the
			// resolve function.
			args: {
				firstName: { type: new GraphQLNonNull(GraphQLString) },
				age: { type: new GraphQLNonNull(GraphQLInt) },
				companyId:  { type: GraphQLString }
			},
			resolve(parentValue, { firstName, age }) {
				return axios.post('http://localhost:3000/users', { firstName, age })
					.then(res => res.data);
			}
		}
	}
});
```